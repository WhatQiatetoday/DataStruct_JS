<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>回文检测</title>
</head>

<body>
    <script>
        class DeQueue {
            constructor() {
                this.items = {};
                this.count = 0;
                this.lowestCount = 0;
            }
            // addFront(element) - 在双端队列前端添加新的元素
            addFront(element) {
                if (this.isEmpty()) {
                    this.addBack(element);
                } else if (this.lowestCount > 0) {
                    this.lowestCount--;
                    this.items[this.lowestCount] = element;
                } else {
                    for (let i = this.count; i > 0; i--) {
                        this.items[i] = this.items[i - 1];
                    }
                    this.count++;
                    this.items[0] = element;
                }
            }
            // addBack(element) - 在双端队列后端添加新的元素
            addBack(element) {
                this.items[this.count] = element;
                this.count++;
            }
            // removeFront() - 从双端队列前端移除第一个元素
            removeFront() {
                if (this.isEmpty()) {
                    return undefined;
                }
                const result = this.items[this.lowestCount];
                delete this.items[this.lowestCount];
                this.lowestCount++;
                return result;
            }
            // removeBack() - 从双端队列后端移除第一个元素
            removeBack() {
                if (this.isEmpty()) {
                    return undefined;
                }
                this.count--;
                const result = this.items[this.count];
                delete this.items[this.count]
                return result;
            }
            // peekFront() - 返回双端队列前端的第一个元素
            peekFront() {
                if (this.isEmpty()) {
                    return undefined;
                }
                return this.items[this.lowestCount];
            }
            // peekBack() - 返回双端队列后端的第一个元素
            peekBack() {
                if (this.isEmpty()) {
                    return undefined;
                }
                return this.items[this.count - 1];
            }
            // isEmpty() - 判断双端队列是否为空
            isEmpty() {
                return this.size() === 0;
            }
            // clear() - 清空双端队列
            clear() {
                this.count = 0;
                this.lowestCount = 0;
                this.items = {};
            }
            // size() - 返回双端队列包含的元素个数
            size() {
                return this.count - this.lowestCount;
            }
            // toString() - 将双端队列中的元素以字符串形式返回
            toString() {
                if (this.isEmpty()) {
                    return ''
                }
                let str = '';
                for (let i = this.lowestCount; i < this.count; i++) {
                    str += `${this.items[i]} `;
                }
                return str;
            }
        }

        function test(str) {
            let deQueue = new DeQueue();
            const lowstr = str.toLocaleLowerCase().split(' ').join('');
            for (let i = 0; i < lowstr.length; i++) {
                deQueue.addBack(lowstr[i]);
            }
            let isEqual = true;
            while (deQueue.size() > 1) {
                if (deQueue.removeFront() !== deQueue.removeBack()) {
                    isEqual = false;
                    break;
                }
            }
            return isEqual;
        }

    </script>
</body>

</html>